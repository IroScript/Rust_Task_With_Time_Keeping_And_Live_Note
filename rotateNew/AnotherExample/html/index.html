<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Rotate Demo â€” Pure Rust (egui/eframe)</title>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Syne:wght@700;800&display=swap" rel="stylesheet"/>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    background: #0d0d0d;
    color: #c5c8c6;
    font-family: 'JetBrains Mono', monospace;
    padding: 30px 20px 80px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 32px;
  }
  h1 {
    font-family: 'Syne', sans-serif;
    font-size: 22px;
    color: #e8ff47;
    letter-spacing: 0.08em;
    text-align: center;
  }
  .subtitle {
    font-size: 12px;
    color: #555;
    text-align: center;
    line-height: 1.6;
    max-width: 700px;
  }
  .subtitle strong { color: #f0f0f0; }
  .subtitle code {
    background: #1a1a1a;
    color: #e8ff47;
    padding: 1px 6px;
    font-size: 11px;
  }
  .file-block {
    width: 100%;
    max-width: 980px;
    border: 2px solid #2a2a2a;
    background: #141414;
    position: relative;
  }
  .file-tag {
    position: absolute;
    top: -11px;
    left: 20px;
    font-size: 10px;
    letter-spacing: 0.15em;
    background: #ff6633;
    color: #fff;
    padding: 2px 10px;
    font-weight: 700;
    z-index: 2;
  }
  .file-header {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 16px 20px 12px;
    border-bottom: 1px solid #2a2a2a;
  }
  .dot { width: 10px; height: 10px; border-radius: 50%; }
  .dot.r { background: #ff4757; }
  .dot.y { background: #e8ff47; }
  .dot.g { background: #4cd137; }
  .file-name {
    margin-left: 12px;
    font-size: 11px;
    color: #555;
    letter-spacing: 0.08em;
  }
  .file-lang {
    margin-left: auto;
    font-size: 11px;
    color: #ff6633;
    font-weight: 700;
    letter-spacing: 0.1em;
  }
  .copy-btn {
    margin-left: 16px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    background: #2a2a2a;
    color: #999;
    border: 1px solid #333;
    padding: 4px 12px;
    cursor: pointer;
    letter-spacing: 0.08em;
    transition: background 0.2s, color 0.2s;
  }
  .copy-btn:hover { background: #e8ff47; color: #0d0d0d; }
  .copy-btn.copied { background: #4cd137; color: #0d0d0d; }
  .file-body {
    padding: 20px;
    overflow-x: auto;
    overflow-y: auto;
  }
  .file-body pre {
    font-family: 'JetBrains Mono', monospace;
    font-size: 12.5px;
    line-height: 1.7;
    color: #c5c8c6;
    white-space: pre;
    tab-size: 4;
  }
  /* syntax classes */
  .kw { color: #ff6633; font-weight: 700; }
  .fn { color: #e8ff47; }
  .st { color: #4cd137; }
  .cm { color: #555; font-style: italic; }
  .tp { color: #00d2ff; }
  .mc { color: #b088f9; }
  .nm { color: #ff4757; }
  .at { color: #ff6633; }
</style>
</head>
<body>

<h1>ğŸ¦€ Rotate Demo â€” Pure Rust (egui / eframe)</h1>
<div class="subtitle">
  <strong>No browser. No WASM. No CSS.</strong> This is a native desktop app rendered via GPU (OpenGL/wgpu).<br/>
  Text rotation via <code>TextShape { angle }</code> â€” not <code>painter.text()</code> which stays axis-aligned.<br/>
  Rectangles via <code>convex_polygon</code> + 2D rotation matrix: <code>x' = cx + dxÂ·cos(Î¸) âˆ’ dyÂ·sin(Î¸)</code>.<br/>
  Build: <code>cargo run</code> â€” that's it. Every symbol, word, box, class from the HTML version is preserved.
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• src/main.rs â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div class="file-block">
  <div class="file-tag">src/main.rs</div>
  <div class="file-header">
    <div class="dot r"></div>
    <div class="dot y"></div>
    <div class="dot g"></div>
    <span class="file-name">src/main.rs</span>
    <span class="file-lang">RUST ğŸ¦€</span>
    <button class="copy-btn" onclick="copyCode('main')">COPY</button>
  </div>
  <div class="file-body">
    <pre id="mainPre"></pre>
  </div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• Cargo.toml â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div class="file-block">
  <div class="file-tag">Cargo.toml</div>
  <div class="file-header">
    <div class="dot r"></div>
    <div class="dot y"></div>
    <div class="dot g"></div>
    <span class="file-name">Cargo.toml</span>
    <span class="file-lang">TOML</span>
    <button class="copy-btn" onclick="copyCode('cargo')">COPY</button>
  </div>
  <div class="file-body">
    <pre id="cargoPre"></pre>
  </div>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Raw Rust source code as plain strings (for copy button)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const MAIN_RS = `// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Rotate Demo â€” Pure native Rust GUI (egui / eframe)
// NOT web/WASM â€” this is a native desktop app with GPU rendering
// Rotation via Painter API + 2D rotation matrix on all coords
// Text rotation via TextShape { angle } â€” NOT painter.text()
// Every symbol, word, method, class preserved from HTML version
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

use eframe::egui;
use egui::*;
use epaint::TextShape;
use std::f32::consts::FRAC_PI_2;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Colors â€” exact matches to CSS :root variables
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const BG:      Color32 = Color32::from_rgb(0x0d, 0x0d, 0x0d);
const PANEL:   Color32 = Color32::from_rgb(0x14, 0x14, 0x14);
const BORDER:  Color32 = Color32::from_rgb(0x2a, 0x2a, 0x2a);
const ACCENT:  Color32 = Color32::from_rgb(0xe8, 0xff, 0x47);  // --accent:  #e8ff47
const ACCENT2: Color32 = Color32::from_rgb(0xff, 0x47, 0x57);  // --accent2: #ff4757
const ACCENT3: Color32 = Color32::from_rgb(0x00, 0xd2, 0xff);  // --accent3: #00d2ff
const ACCENT4: Color32 = Color32::from_rgb(0xb0, 0x88, 0xf9);  // --accent4: #b088f9
const TEXT_C:  Color32 = Color32::from_rgb(0xf0, 0xf0, 0xf0);
const MUTED:   Color32 = Color32::from_rgb(0x55, 0x55, 0x55);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  BoxData â€” represents each child box (all 9 preserved)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#[derive(Clone)]
struct BoxData {
    label:     &'static str,
    title:     &'static str,
    value:     &'static str,
    bar_width: f32,      // 0.0 .. 1.0
    color:     Color32,
    wide:      bool,
}

// â”€â”€ All 9 boxes â€” nothing deleted, nothing changed â”€â”€
fn all_boxes() -> [BoxData; 9] {
    [
        BoxData { label: "Box 01",          title: "CPU Usage",         value: "74%",      bar_width: 0.74, color: ACCENT,  wide: false },
        BoxData { label: "Box 02",          title: "Memory",            value: "3.2 GB",   bar_width: 0.55, color: ACCENT2, wide: false },
        BoxData { label: "Box 03",          title: "Network",           value: "\\u{2191} 88ms",   bar_width: 0.30, color: ACCENT3, wide: false },
        BoxData { label: "Box 04 \\u{2014} Wide",   title: "Disk I/O Activity", value: "1.4 TB",   bar_width: 0.80, color: ACCENT4, wide: true  },
        BoxData { label: "Box 05",          title: "Threads",           value: "128",      bar_width: 0.60, color: ACCENT,  wide: false },
        BoxData { label: "Box 06",          title: "Errors",            value: "0",        bar_width: 0.00, color: ACCENT2, wide: false },
        BoxData { label: "Box 07",          title: "Requests",          value: "4.2k",     bar_width: 0.90, color: ACCENT3, wide: false },
        BoxData { label: "Box 08 \\u{2014} Wide",   title: "Active Sessions",   value: "217 live", bar_width: 0.65, color: ACCENT4, wide: true  },
        BoxData { label: "Box 09",          title: "Uptime",            value: "99.9%",    bar_width: 0.99, color: ACCENT,  wide: false },
    ]
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  RotateApp â€” the entire application state
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
struct RotateApp {
    step:          i32,
    target_angle:  f32,   // radians â€” where we want to be
    current_angle: f32,   // radians â€” smoothly interpolated
}

impl RotateApp {
    fn new(cc: &eframe::CreationContext<'_>) -> Self {
        // Dark theme matching CSS :root variables
        let mut visuals = egui::Visuals::dark();
        visuals.panel_fill = BG;
        cc.egui_ctx.set_visuals(visuals);

        Self {
            step:          0,
            target_angle:  0.0,
            current_angle: 0.0,
        }
    }

    // â”€â”€ rotate() â€” preserved exactly from JS version â”€â”€
    //    step += 1;
    //    const angle = step * 90;
    fn rotate(&mut self) {
        self.step += 1;
        self.target_angle = self.step as f32 * FRAC_PI_2;  // 90Â° in radians
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  eframe::App â€” the main loop (replaces the browser event loop)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
impl eframe::App for RotateApp {
    fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
        // â”€â”€ Smooth animation (replaces CSS transition) â”€â”€
        // cubic-bezier feel via exponential interpolation
        let dt = ctx.input(|i| i.predicted_dt);
        let speed = 8.0_f32;
        self.current_angle += (self.target_angle - self.current_angle)
            * (1.0 - (-speed * dt).exp());

        if (self.current_angle - self.target_angle).abs() > 0.001 {
            ctx.request_repaint();  // keep animating
        }

        // â”€â”€ CentralPanel (replaces <body>) â”€â”€
        egui::CentralPanel::default()
            .frame(egui::Frame::none().fill(BG).inner_margin(40.0))
            .show(ctx, |ui| {
                ui.vertical_centered(|ui| {

                    // â”€â”€ CONTROLS (replaces <div class="controls">) â”€â”€
                    ui.horizontal(|ui| {
                        // âŸ³ Rotate button
                        let btn = egui::Button::new(
                            RichText::new("\\u{27F3} Rotate")
                                .size(15.0)
                                .strong()
                                .color(BG)
                        )
                        .fill(ACCENT)
                        .min_size(vec2(140.0, 42.0));

                        if ui.add(btn).clicked() {
                            self.rotate();
                        }

                        ui.add_space(20.0);

                        // Step / Angle label
                        let display_angle = (self.step * 90) % 360;
                        ui.label(RichText::new("Step: ").size(12.0).color(MUTED));
                        ui.label(RichText::new(format!("{}", self.step)).size(12.0).color(ACCENT).strong());
                        ui.label(RichText::new(" | Angle: ").size(12.0).color(MUTED));
                        ui.label(RichText::new(format!("{}\\u{00B0}", display_angle)).size(12.0).color(ACCENT).strong());
                    });

                    ui.add_space(40.0);

                    // â”€â”€ SCENE (replaces <div class="scene">) â”€â”€
                    // Allocate painter area for custom rotated rendering
                    let (resp, painter) = ui.allocate_painter(
                        vec2(620.0, 580.0),
                        egui::Sense::hover(),
                    );
                    let center = resp.rect.center();

                    // â–‘â–‘ MASTER BOX â€” paint everything rotated â–‘â–‘
                    paint_master_box(&painter, center, self.current_angle);
                    // â–‘â–‘ end master box â–‘â–‘
                });
            });
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  2D Rotation helpers â€” this IS the rotation mechanism
//  (replaces CSS transform: rotate(Ndeg))
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// Rotate a point around a center using 2D rotation matrix
///   x' = cx + (x-cx)Â·cos(Î¸) âˆ’ (y-cy)Â·sin(Î¸)
///   y' = cy + (x-cx)Â·sin(Î¸) + (y-cy)Â·cos(Î¸)
fn rot_point(p: Pos2, center: Pos2, cos_a: f32, sin_a: f32) -> Pos2 {
    let dx = p.x - center.x;
    let dy = p.y - center.y;
    pos2(
        center.x + dx * cos_a - dy * sin_a,
        center.y + dx * sin_a + dy * cos_a,
    )
}

/// Draw a rotated filled rectangle via convex_polygon
fn rotated_rect(
    painter: &Painter,
    center: Pos2,
    rect: Rect,
    cos_a: f32,
    sin_a: f32,
    fill: Color32,
    stroke: Stroke,
) {
    let corners = vec![
        rot_point(rect.left_top(),     center, cos_a, sin_a),
        rot_point(rect.right_top(),    center, cos_a, sin_a),
        rot_point(rect.right_bottom(), center, cos_a, sin_a),
        rot_point(rect.left_bottom(),  center, cos_a, sin_a),
    ];
    painter.add(epaint::Shape::convex_polygon(corners, fill, stroke));
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Rotated text helper â€” uses TextShape with angle field
//  (painter.text() does NOT rotate glyphs, only position)
//  TextShape { angle } rotates the actual rendered glyphs
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// Draw text that is actually rotated (glyphs rotate with the angle).
/// This is the FIX for the painter.text() limitation.
/// painter.text() only moves position but glyphs stay axis-aligned.
/// TextShape { angle } rotates the actual text rendering.
fn paint_rotated_text(
    painter: &Painter,
    pos: Pos2,              // already-rotated position
    anchor: Align2,         // alignment anchor
    text: &str,
    font: FontId,
    color: Color32,
    angle: f32,             // rotation angle in radians
) {
    let galley = painter.layout_no_wrap(
        text.to_string(),
        font,
        color,
    );

    // Calculate anchored position (Align2 offset)
    let galley_size = galley.size();
    let offset = vec2(
        match anchor.x() {
            Align::LEFT  => 0.0,
            Align::Center => -galley_size.x * 0.5,
            Align::RIGHT => -galley_size.x,
            _ => 0.0,
        },
        match anchor.y() {
            Align::TOP    => 0.0,
            Align::Center => -galley_size.y * 0.5,
            Align::BOTTOM => -galley_size.y,
            _ => 0.0,
        },
    );

    // Rotate the offset vector by the angle so it aligns with rotated frame
    let cos_a = angle.cos();
    let sin_a = angle.sin();
    let rotated_offset = vec2(
        offset.x * cos_a - offset.y * sin_a,
        offset.x * sin_a + offset.y * cos_a,
    );

    let final_pos = pos + rotated_offset;

    let text_shape = TextShape {
        pos: final_pos,
        galley,
        underline: Stroke::NONE,
        fallback_color: color,
        override_text_color: Some(color),
        opacity_factor: 1.0,
        angle,              // âœ… THIS is the key â€” rotates actual glyphs
    };

    painter.add(text_shape);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Paint the master box + all 9 child boxes, fully rotated
//  (replaces the entire <div class="master-box"> HTML tree)
//  ALL text now uses paint_rotated_text() with TextShape
//  so glyphs rotate WITH the boxes â€” not just their positions
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
fn paint_master_box(painter: &Painter, center: Pos2, angle: f32) {
    let cos_a = angle.cos();
    let sin_a = angle.sin();
    let rot = |p: Pos2| rot_point(p, center, cos_a, sin_a);

    // â”€â”€ Master box dimensions â”€â”€
    let master_w = 560.0_f32;
    let master_h = 500.0_f32;
    let master_rect = Rect::from_center_size(center, vec2(master_w, master_h));

    // Master box background + 2px border
    rotated_rect(
        painter, center, master_rect,
        cos_a, sin_a,
        PANEL,
        Stroke::new(2.0, BORDER),
    );

    // "MASTER BOX" corner tag
    let tag_rect = Rect::from_min_size(
        pos2(master_rect.left() + 20.0, master_rect.top() - 11.0),
        vec2(90.0, 16.0),
    );
    rotated_rect(painter, center, tag_rect, cos_a, sin_a, ACCENT, Stroke::NONE);

    // âœ… FIXED: "MASTER BOX" text now rotates with the box
    paint_rotated_text(
        painter,
        rot(tag_rect.center()),
        Align2::CENTER_CENTER,
        "MASTER BOX",
        FontId::monospace(9.0),
        BG,
        angle,
    );

    // â”€â”€ Grid layout (3 columns, matching CSS grid) â”€â”€
    let padding = 28.0_f32;
    let gap     = 16.0_f32;
    let inner_w = master_w - padding * 2.0;
    let col_w   = (inner_w - gap * 2.0) / 3.0;
    let row_h   = 96.0_f32;
    let start_x = master_rect.left() + padding;
    let start_y = master_rect.top() + padding + 8.0;

    let boxes = all_boxes();
    let mut col: usize = 0;
    let mut row: usize = 0;

    for b in &boxes {
        let span = if b.wide { 2 } else { 1 };
        let w = col_w * span as f32 + gap * (span - 1) as f32;
        let x = start_x + col as f32 * (col_w + gap);
        let y = start_y + row as f32 * (row_h + gap);

        // â”€â”€ Child box background + 1px border â”€â”€
        let box_rect = Rect::from_min_size(pos2(x, y), vec2(w, row_h));
        rotated_rect(painter, center, box_rect, cos_a, sin_a,
            PANEL, Stroke::new(1.0, BORDER));

        // â”€â”€ Left color accent bar (3px, like .box::after) â”€â”€
        let accent_rect = Rect::from_min_size(pos2(x, y), vec2(3.0, row_h));
        rotated_rect(painter, center, accent_rect, cos_a, sin_a,
            b.color, Stroke::NONE);

        // â”€â”€ .box-label â”€â”€ âœ… FIXED: uses TextShape with angle
        paint_rotated_text(
            painter,
            rot(pos2(x + 14.0, y + 14.0)),
            Align2::LEFT_CENTER,
            b.label,
            FontId::monospace(9.0),
            MUTED,
            angle,
        );

        // â”€â”€ .box-title â”€â”€ âœ… FIXED: uses TextShape with angle
        paint_rotated_text(
            painter,
            rot(pos2(x + 14.0, y + 34.0)),
            Align2::LEFT_CENTER,
            b.title,
            FontId::proportional(14.0),
            TEXT_C,
            angle,
        );

        // â”€â”€ .box-value â”€â”€ âœ… FIXED: uses TextShape with angle
        paint_rotated_text(
            painter,
            rot(pos2(x + 14.0, y + 58.0)),
            Align2::LEFT_CENTER,
            b.value,
            FontId::monospace(18.0),
            b.color,
            angle,
        );

        // â”€â”€ .bar-track â”€â”€
        let bar_y = y + 80.0;
        let track_rect = Rect::from_min_size(
            pos2(x + 14.0, bar_y),
            vec2(w - 28.0, 3.0),
        );
        rotated_rect(painter, center, track_rect, cos_a, sin_a,
            BORDER, Stroke::NONE);

        // â”€â”€ .bar-fill â”€â”€
        let fill_w = (w - 28.0) * b.bar_width;
        if fill_w > 0.0 {
            let fill_rect = Rect::from_min_size(
                pos2(x + 14.0, bar_y),
                vec2(fill_w, 3.0),
            );
            rotated_rect(painter, center, fill_rect, cos_a, sin_a,
                b.color, Stroke::NONE);
        }

        // Advance grid position
        col += span;
        if col >= 3 { col = 0; row += 1; }
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  main â€” entry point (native desktop window, not a browser)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
fn main() -> eframe::Result {
    let options = eframe::NativeOptions {
        viewport: egui::ViewportBuilder::default()
            .with_inner_size([800.0, 700.0])
            .with_title("Rotate Demo"),
        ..Default::default()
    };

    eframe::run_native(
        "Rotate Demo",
        options,
        Box::new(|cc| Ok(Box::new(RotateApp::new(cc)))),
    )
}`;

const CARGO_TOML = `# Cargo.toml â€” Pure native Rust (no WASM, no browser)

[package]
name    = "rotate-demo"
version = "0.1.0"
edition = "2021"

[dependencies]
eframe = "0.28"    # egui framework â€” GPU-rendered native GUI
epaint = "0.28"    # needed for TextShape (rotated text rendering)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Build & run:
#   cargo run
#
# That's it. No trunk, no wasm-pack, no wasm32 target,
# no index.html, no browser. A native desktop window
# with OpenGL/wgpu rendering and real rotation via
# the Painter API + 2D rotation matrix.
#
# KEY FIX: Text rotation uses TextShape { angle }
# instead of painter.text() which keeps glyphs
# axis-aligned (screen-horizontal) regardless of
# position rotation. TextShape.angle rotates the
# actual rendered glyphs.
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Syntax highlighting (applied to the displayed version only)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function highlight(src) {
  // Escape HTML first
  let code = src
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');

  // Comments (// and /// and #)
  code = code.replace(/(\/\/\/?.*)$/gm, '<span class="cm">$1</span>');
  code = code.replace(/^(\s*#[^[\n].*)$/gm, '<span class="cm">$1</span>');

  // Strings
  code = code.replace(/"([^"\\]|\\.)*"/g, '<span class="st">$&</span>');

  // Attributes #[...]
  code = code.replace(/#\[([^\]]+)\]/g, '<span class="at">#[$1]</span>');

  // Keywords
  const keywords = ['use','const','fn','struct','impl','let','mut','self','if','else','for','in','as','true','false','return','pub','mod','crate','extern','where','type','enum','match','loop','while','break','continue','move','ref','static','unsafe','trait','dyn','async','await','macro_rules'];
  keywords.forEach(kw => {
    const re = new RegExp('\\b(' + kw + ')\\b', 'g');
    code = code.replace(re, (m) => {
      return '<span class="kw">' + m + '</span>';
    });
  });

  // Types
  const types = ['Color32','BoxData','RotateApp','Pos2','Rect','Painter','Stroke','Align2','Align','FontId','RichText','Vec2','App','Context','Frame','CreationContext','CentralPanel','Button','Visuals','ViewportBuilder','NativeOptions','Shape','Sense','Self','Result','Box','Ok','Default','TextShape','Galley','Arc','Some','None','f32','f64','i32','i64','u8','u16','u32','u64','usize','isize','bool','str','String','LEFT','RIGHT','CENTER','Center','TOP','BOTTOM','NONE'];
  types.forEach(tp => {
    const re = new RegExp('\\b(' + tp + ')\\b', 'g');
    code = code.replace(re, '<span class="tp">$1</span>');
  });

  // Numbers (hex and decimal)
  code = code.replace(/\b(0x[0-9a-fA-F]+|[0-9]+\.?[0-9]*(?:_f32|_f64)?)\b/g, '<span class="nm">$1</span>');

  // Macros
  code = code.replace(/\b(format!|vec!|println!|eprintln!|todo!|panic!|assert!|dbg!)/g, '<span class="mc">$1</span>');

  return code;
}

// Render highlighted code
document.getElementById('mainPre').innerHTML = highlight(MAIN_RS);
document.getElementById('cargoPre').innerHTML = highlight(CARGO_TOML);

// Copy functionality
function copyCode(which) {
  const text = which === 'main' ? MAIN_RS : CARGO_TOML;
  navigator.clipboard.writeText(text).then(() => {
    const btns = document.querySelectorAll('.copy-btn');
    const btn = which === 'main' ? btns[0] : btns[1];
    btn.textContent = 'COPIED âœ“';
    btn.classList.add('copied');
    setTimeout(() => {
      btn.textContent = 'COPY';
      btn.classList.remove('copied');
    }, 2000);
  });
}
</script>

</body>
</html>
